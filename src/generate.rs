use std::path::Path;

use crate::{
  parse::{
    Comment, EnumDefinition, FunctionDefinition, IncludeDefinition, Requiredness,
    ServiceDefinition, StructDefinition, ThriftDocument, ThriftType,
  },
  visit::Visit,
};

const INDENT: &'static str = "  ";

pub struct GenerateOptions {
  i64_as_string: bool,
  options_type_code: Option<String>,
  fetch_declaration_code: Option<String>,
}

impl Default for GenerateOptions {
  fn default() -> Self {
    Self {
      i64_as_string: false,
      options_type_code: Some("any".to_string()),
      fetch_declaration_code: None,
    }
  }
}

pub struct Generator<'a> {
  document: &'a mut ThriftDocument,
}

impl<'a> Generator<'a> {
  pub fn new(document: &'a mut ThriftDocument) -> Self {
    Self { document }
  }

  pub fn build(&mut self, options: GenerateOptions) -> String {
    let mut visitor = Visitor::new(options);
    visitor.visit_document(&mut self.document);
    visitor.code
  }
}

struct Visitor {
  pub code: String,
  options: GenerateOptions,
  service_visited: bool,
}

impl Visitor {
  pub fn new(options: GenerateOptions) -> Self {
    Self {
      code: String::from(
        r#"/* eslint-disable */
// @ts-nocheck
// This file is auto generated by thrift_parser.

"#,
      ),
      options,
      service_visited: false,
    }
  }

  fn format_comments(&self, comments: &Vec<Comment>, indent: &str) -> String {
    if comments.is_empty() {
      return "".to_string();
    }

    let mut code = indent.to_string() + "/**";

    let is_single_comment = comments.len() == 1
      && match &comments[0] {
        Comment::Line(_) => true,
        Comment::Block(block) => block.value.len() == 1,
      };

    // 如果只有一行注释，返回 /** {} */ 这样的格式
    if is_single_comment {
      code.push_str(format!(" {} */\n", comments[0].line_value()).as_str());
      return code;
    } else {
      code.push_str("\n");
    }

    for (index, comment) in comments.iter().enumerate() {
      if index > 0 {
        code.push_str(indent);
        code.push_str(" *\n");
      }

      code.push_str(indent);
      code.push_str(" * ");

      match comment {
        Comment::Line(line) => {
          code.push_str(&line.value);
        }
        Comment::Block(block) => {
          for line in &block.value {
            code.push_str(indent);
            code.push_str(" * ");
            code.push_str(&line);
          }
        }
      }

      code.push_str("\n");
    }

    code.push_str(&indent);
    code.push_str(" */\n");

    code
  }

  fn format_thrift_type(&self, thrift_type: &ThriftType) -> String {
    match &thrift_type {
      ThriftType::Void => "void".to_string(),
      ThriftType::String => "string".to_string(),
      ThriftType::I16 => "number".to_string(),
      ThriftType::I32 => "number".to_string(),
      ThriftType::I64 => {
        if self.options.i64_as_string {
          "string".to_string()
        } else {
          "number".to_string()
        }
      }
      ThriftType::Double => "number".to_string(),
      ThriftType::Bool => "boolean".to_string(),
      ThriftType::List(ty) => format!("Array<{}>", self.format_thrift_type(ty)),
      ThriftType::Map(key_ty, value_ty) => format!(
        "Record<{}, {}>",
        self.format_thrift_type(key_ty),
        self.format_thrift_type(value_ty)
      ),
      ThriftType::Identifier(id) => id.value.clone(),
    }
  }
}

impl Visit for Visitor {
  fn visit_include_definition(&mut self, include_definition: &mut IncludeDefinition) {
    let path = Path::new(&include_definition.path.value)
      .file_stem()
      .unwrap()
      .to_str()
      .unwrap();
    let code = format!("import * as {} from './{}';\n", path, path);

    self.code.push_str(&code);
  }

  fn visit_struct_definition(&mut self, struct_definition: &mut StructDefinition) {
    let mut code = "\n".to_string();

    code.push_str(
      self
        .format_comments(&struct_definition.comments, "")
        .as_str(),
    );
    code.push_str(format!("export interface {} {{\n", struct_definition.name.value).as_str());

    for field in &struct_definition.fields {
      code.push_str(&self.format_comments(&field.comments, &INDENT));
      code.push_str(INDENT);
      code.push_str(&field.name.value);

      if matches!(field.requiredness, Some(Requiredness::Optional)) {
        code.push_str("?");
      }

      code.push_str(": ");
      code.push_str(&self.format_thrift_type(&field.field_type));
      code.push_str(";\n");
    }

    code.push_str("}\n");
    self.code.push_str(&code);
  }

  fn visit_enum_definition(&mut self, enum_definition: &mut EnumDefinition) {
    let mut code = "\n".to_string();

    code.push_str(self.format_comments(&enum_definition.comments, "").as_str());
    code.push_str(format!("export enum {} {{\n", enum_definition.name.value).as_str());

    for member in &enum_definition.members {
      code.push_str(&self.format_comments(&member.comments, &INDENT));
      code.push_str(INDENT);
      code.push_str(&member.name.value);

      if let Some(initializer) = &member.initializer {
        code.push_str(" = ");
        code.push_str(&initializer.value);
      }
      code.push_str(",\n");
    }

    code.push_str("}\n");
    self.code.push_str(&code);
  }

  fn visit_service_definition(&mut self, service_definition: &mut ServiceDefinition) {
    if !self.service_visited {
      self.service_visited = true;

      if let Some(fetch_declaration_code) = &self.options.fetch_declaration_code {
        self.code.push_str("\n");
        self.code.push_str(fetch_declaration_code.as_str());
        self.code.push_str("\n");
      }

      let options_type = self
        .options
        .options_type_code
        .clone()
        .unwrap_or("any".to_string());

      self
        .code
        .push_str(format!("\ntype _Options = {};\n", options_type).as_str());

      self.code.push_str(
        r#"
let urlPrefix = '';
export function setUrlPrefix(prefix: string) {
  urlPrefix = prefix;
}
"#,
      );
    }

    for function_definition in &mut service_definition.functions {
      self.visit_function_definition(function_definition)
    }
  }

  fn visit_function_definition(&mut self, function_definition: &mut FunctionDefinition) {
    let mut code = "\n".to_string();

    code.push_str(
      self
        .format_comments(&function_definition.comments, "")
        .as_str(),
    );
    code.push_str(format!("export function {}(", function_definition.name.value).as_str());

    let first_arg_name = function_definition
      .fields
      .get(0)
      .map(|field| field.name.value.clone());

    for field in &function_definition.fields {
      code.push_str(&field.name.value);
      code.push_str(": ");
      code.push_str(&self.format_thrift_type(&field.field_type));
      code.push_str(", ");
    }

    code.push_str(
      format!(
        "options: _Options): Promise<{}> {{\n",
        self.format_thrift_type(&function_definition.return_type)
      )
      .as_str(),
    );

    if let Some(annotations) = &function_definition.annotations {
      let mut api_method = None;
      let mut api_path = None;

      for annotation in &annotations.annotations {
        match annotation.name.value.as_str() {
          "api.get" => {
            api_method = Some("GET".to_string());
          }
          "api.post" => {
            api_method = Some("POST".to_string());
          }
          "api.put" => {
            api_method = Some("PUT".to_string());
          }
          "api.delete" => {
            api_method = Some("DELETE".to_string());
          }
          _ => {}
        }

        if api_method.is_some() && api_path.is_none() {
          api_path = Some(annotation.value.value.clone());
        }
      }

      if let Some(api_method) = api_method {
        let mut has_query = false;
        let mut has_body = false;

        if let Some(first_arg_name) = first_arg_name {
          match api_method.as_str() {
            "GET" => {
              has_query = true;
              code.push_str(INDENT);
              code.push_str(
                format!(
                  "const query = new URLSearchParams({}).toString();\n",
                  first_arg_name
                )
                .as_str(),
              )
            }
            _ => {
              has_body = true;
              code.push_str(INDENT);
              code.push_str(format!("const body = JSON.stringify({});\n", first_arg_name).as_str());
            }
          }
        }

        code.push_str(INDENT);

        if has_query {
          code.push_str(
            format!(
              "const url = `${{urlPrefix}}{}?${{query}}`;\n",
              api_path.unwrap()
            )
            .as_str(),
          );
        } else {
          code.push_str(format!("const url = `${{urlPrefix}}{}`;\n", api_path.unwrap()).as_str());
        }

        // return fetch(uri, { method, headers }, option);
        code.push_str(INDENT);

        if has_body {
          code.push_str(
            format!(
              "return fetch(url, {{ method: '{}', body }}, options);\n",
              api_method
            )
            .as_str(),
          );
        } else {
          code.push_str(
            format!(
              "return fetch(url, {{ method: '{}' }}, options);\n",
              api_method
            )
            .as_str(),
          );
        }

        code.push_str("}\n");
        self.code.push_str(code.as_str());
        return;
      }
    }

    code.push_str(INDENT);
    code.push_str("throw new Error('not implemented');\n}}\n");
  }
}
